# OrchestrAI ‚Äì De l‚Äôid√©e √† l‚Äôaction par collaboration d‚Äôagents LLM  
*OrchestrAI ‚Äì From Idea to Action with LLM-Driven Agent Collaboration*

---

[![Cloud Run Ready](https://img.shields.io/badge/cloud--run-ready-brightgreen)](https://cloud.google.com/run) [![Python](https://img.shields.io/badge/python-3.11%2B-blue)](https://python.org/) [![Google ADK](https://img.shields.io/badge/ADK-Google%20Agent2Agent-blueviolet)](https://developers.google.com/agent-framework)

---

## ‚ú® Pitch

> **Fran√ßais :**  
> OrchestrAI transforme tout objectif flou en plan d‚Äôaction d√©taill√©, puis en livrables concrets, gr√¢ce √† une √©quipe d‚Äôagents IA sp√©cialis√©s orchestr√©s dynamiquement. Clarification, planification, ex√©cution : chaque √©tape est automatis√©e, supervis√©e, r√©cup√©rable, et document√©e, tout en int√©grant l‚Äôutilisateur pour garantir pertinence et qualit√©.

> **English:**  
> OrchestrAI turns any vague user goal into a structured plan and concrete deliverables, thanks to a dynamically orchestrated team of specialized AI agents. Clarification, planning, execution: every step is automated, supervised, recoverable, and logged, keeping the user in the loop for quality and relevance.

---

## üöÄ Why OrchestrAI Stands Out

- **Human-in-the-loop automation**: L‚Äôutilisateur reste impliqu√© √† chaque √©tape cl√©.
- **Dynamic agent discovery**: Agents are registered and assigned in real time via the GRA registry.
- **Error resilience & incremental execution**: Plans and tasks can be retried, extended, or patched without losing previous progress.
- **Composable & extensible**: Add new agents/skills anytime‚Äîjust register with the GRA and they‚Äôre orchestrated automatically.
- **A2A protocol & Google ADK compliant**: Ensures interoperability and future-proofing.
- **Full audit trail**: Every decision, correction, and outcome is persisted in Firestore for transparency.

---

## üèóÔ∏è Table des Mati√®res

1. [Architecture Fonctionnelle](#architecture-fonctionnelle)
2. [Architecture Technique](#architecture-technique)
3. [Principaux Concepts](#principaux-concepts)
4. [Installation et Pr√©requis](#installation-et-pr√©requis)
5. [Utilisation](#utilisation)
6. [Structure du Projet](#structure-du-projet)
7. [D√©ploiement Cloud / Firebase](#d√©ploiement-cloud--firebase)
8. [Comment Ajouter Son Agent](#comment-ajouter-son-agent)
9. [Roadmap & Perspectives](#roadmap--perspectives)

---

## üß≠ Architecture Fonctionnelle

**Visualisez ce sch√©ma sur [mermaidchart.com](https://www.mermaidchart.com/app/projects/f16a002d-be5d-43d1-bdfb-c095ee3316f6/diagrams/b4c8f941-5b8a-469c-a670-a87c37b12923/version/v0.1/edit)**

```mermaid
graph TD
    subgraph "Phase 1: Clarification"
        A[Utilisateur] -->|Objectif Initial| B(API Gateway / GRA)
        B --> C{Global Supervisor}
        C --o|Demande clarification| D[User Interaction Agent]
        D --o|Affiche √† l'utilisateur| E[Interface UI]
        E --o|R√©ponse| C
    end
    C -->|Objectif Clarifi√©| F{Planning Supervisor}
    subgraph "Phase 2: Planification (TEAM 1)"
        F -->|G√©n√®re plan| G[Reformulator Agent]
        G -->|√âvalue plan| H[Evaluator Agent]
        H -->|Valide plan| I[Validator Agent]
        I -- "Si plan rejet√©" --> F
    end
    I -- "Plan Valid√©" --> J{Execution Supervisor}
    subgraph "Phase 3: Ex√©cution (TEAM 2)"
        J -->|D√©composer plan| K[Decomposition Agent]
        K -->|Execution Task Graph| J
        J -- "Orchestre t√¢ches" --> L((Pool d'Agents d'Ex√©cution))
        subgraph L
            direction LR
            L1[Development Agent]
            L2[Research Agent]
            L3[Testing Agent]
        end
        L -- "Artefacts" --> J
    end
    J -->|R√©sultats Finaux| M[Output]
```
https://www.mermaidchart.com/app/projects/f16a002d-be5d-43d1-bdfb-c095ee3316f6/diagrams/b4c8f941-5b8a-469c-a670-a87c37b12923/version/v0.1/edit


### √âtape 1 : Clarification de l'Objectif (Orchestr√©e par `GlobalSupervisorLogic`)

Cette phase cruciale garantit que l'objectif soumis par l'utilisateur est suffisamment clair et d√©taill√© avant d'engager des ressources dans la planification ou l'ex√©cution.

* **Soumission d'Objectif** : L'utilisateur initie le processus via l'interface Streamlit (`app_frontend.py`), qui communique avec l'API du GRA.
* **Orchestration Globale** : Le `GlobalSupervisorLogic` enregistre l'objectif et g√®re l'√©tat du dialogue dans la collection `global_plans` de Firestore.
* **Dialogue Interactif via `UserInteractionAgent`** :
    * Le `GlobalSupervisorLogic` invoque le `UserInteractionAgent`.
    * Cet agent utilise un LLM pour analyser l'objectif, estimer son type (ex: "Software Development", "Redaction/Research"), identifier les manques d'informations critiques, proposer des enrichissements, et formuler des questions √† l'utilisateur. Il retourne un JSON structur√©.
    * L'√©tat du plan global passe √† `CLARIFICATION_PENDING_USER_INPUT`.
* **Boucle de Clarification via Streamlit** : L'interface affiche la question, l'objectif enrichi (√©ditable), et les √©l√©ments assum√©s. L'utilisateur r√©pond ou modifie l'objectif.
* **Acceptation de l'Objectif** : Si l'objectif est jug√© satisfaisant, l'utilisateur valide, le `GlobalSupervisorLogic` marque l'objectif comme `OBJECTIVE_CLARIFIED` et initie la phase suivante (TEAM 1).

### √âtape 2 : G√©n√©ration et It√©ration de Plan (TEAM 1 : PLAN GENERATION, Orchestr√©e par `PlanningSupervisorLogic`)

Une fois l'objectif clarifi√©, cette phase cr√©e un plan d'action d√©taill√©.

* **Orchestration Centralis√©e (TEAM 1)** : Le `PlanningSupervisorLogic` pilote le flux, recevant l'objectif clarifi√© du `GlobalSupervisorLogic`.
* **Reformulation** : `ReformulatorAgent` g√©n√®re un plan d'action d√©taill√© via LLM.
* **√âvaluation** : `EvaluatorAgent` analyse le plan, identifie forces/faiblesses, et donne un score de faisabilit√© (via LLM), retournant un JSON.
* **Validation** : `ValidatorAgent` approuve ou rejette le plan avec justification (via LLM).
* **Boucle de R√©vision** : En cas de rejet, le `PlanningSupervisorLogic` int√®gre les commentaires et relance une reformulation (jusqu'√† `max_revisions`).

### √âtape 3 : Ex√©cution du Plan (TEAM 2 : PLAN EXECUTION, Orchestr√©e par `ExecutionSupervisorLogic`)

Apr√®s la validation du plan d√©taill√© par TEAM 1, cette nouvelle phase prend en charge son ex√©cution concr√®te.

* **Initiation par `GlobalSupervisorLogic`** : Une fois que TEAM 1 a produit un plan valid√© (`TEAM1_PLANNING_COMPLETED`), le `GlobalSupervisorLogic` initie TEAM 2. Il r√©cup√®re le plan final de TEAM 1 et le transmet √† `ExecutionSupervisorLogic`.
* **Orchestration de l'Ex√©cution (`ExecutionSupervisorLogic`)** :
    * Ce superviseur prend le plan valid√© de TEAM 1.
    * **D√©composition du Plan d'Ex√©cution** : Il invoque le `DecompositionAgent`. Cet agent prend le plan textuel de TEAM 1 et le d√©compose en une structure JSON globale de t√¢ches granulaires (un `ExecutionTaskGraph`) adapt√©es √† l'ex√©cution. Cette structure inclut le contexte global, les instructions, et une liste de t√¢ches avec leurs descriptions, types (`executable`, `exploratory`, `container`), d√©pendances, instructions locales, crit√®res d'acceptation et le type d'agent d'ex√©cution sugg√©r√©.
    * **Gestion de l'`ExecutionTaskGraph`** : `ExecutionSupervisorLogic` g√®re ce graphe de t√¢ches d'ex√©cution, stock√© dans Firestore (collection `execution_task_graphs`).
    * **Assignation et Ex√©cution des T√¢ches** : Pour chaque t√¢che pr√™te dans l'`ExecutionTaskGraph`:
        * `ExecutionSupervisorLogic` identifie la comp√©tence requise (ex: `coding_python`, `web_research`, `software_testing`).
        * Il d√©couvre un agent appropri√© via le GRA. Les agents d'ex√©cution disponibles sont :
            * `DevelopmentAgent`: Pour les t√¢ches de g√©n√©ration de code (ex: comp√©tence `coding_python`).
            * `ResearchAgent`: Pour les t√¢ches de recherche, d'analyse ou de synth√®se de documents (comp√©tences `general_analysis`, `web_research`, `document_synthesis`).
            * `TestingAgent`: Pour tester les livrables, comme du code, par rapport √† des sp√©cifications (comp√©tence `software_testing`).
        * L'agent s√©lectionn√© ex√©cute la t√¢che et produit des artefacts (ex: code source, rapport de recherche, rapport de test).
    * **Gestion des T√¢ches Exploratoires** : Les t√¢ches de type `exploratory` (souvent g√©r√©es par `ResearchAgent`) peuvent retourner des r√©sultats qui incluent la d√©finition de nouvelles sous-t√¢ches, enrichissant dynamiquement l'`ExecutionTaskGraph`.
* **Suivi et Finalisation** : `ExecutionSupervisorLogic` suit l'√©tat de toutes les t√¢ches d'ex√©cution. Une fois toutes les t√¢ches termin√©es, l'√©tat global du plan d'ex√©cution (`EXECUTION_COMPLETED_SUCCESSFULLY` ou `EXECUTION_COMPLETED_WITH_FAILURES`) est d√©termin√©. Le `GlobalSupervisorLogic` met √† jour l'√©tat du `global_plan` en cons√©quence.
* **Reprise d'un Plan en Cours** : la nouvelle m√©thode `continue_execution` permet de relancer un plan existant lorsque des t√¢ches demeurent en `pending` ou `ready`. Un bouton "Reprendre l'ex√©cution" est disponible dans l'interface React pour d√©clencher cette action.

### Capacit√©s Transverses :

* **D√©couverte de Services** : Les agents s'enregistrent aupr√®s du GRA. Les superviseurs interrogent le GRA pour localiser les agents.
* **Persistance des Donn√©es** :
    * `global_plans`: √âtat des plans globaux et dialogue de clarification.
    * `task_graphs`: Plans d√©taill√©s de TEAM 1.
    * `execution_task_graphs`: Plans d'ex√©cution d√©compos√©s et √©tat des t√¢ches de TEAM 2. (Nouvelle collection)
    * `agents`: Enregistrement des agents par le GRA.
* **Interface Utilisateur et Monitoring (Streamlit)** : Permet la soumission d'objectifs, le dialogue de clarification, le listage des plans globaux, la visualisation des graphes de t√¢ches (TEAM 1 et potentiellement TEAM 2), la consultation des artefacts et le statut des agents.

## Architecture Technique

```mermaid
graph LR
    %% --- FRONTENDS ---
    subgraph "Frontends"
        User[(Utilisateur)]
        StreamlitUI[Streamlit UI]
        ReactUI["React (Firebase Hosting)"]
        User --> StreamlitUI
        User --> ReactUI
    end

    %% --- BACKEND sur Cloud Run ---
    subgraph "Cloud Run Services"
        GRA[fa:fa-server GRA / API Gateway]
        GlobalSupervisor[fa:fa-brain Global Supervisor]
        PlanningSupervisor[fa:fa-clipboard-list Planning Supervisor]
        ExecutionSupervisor[fa:fa-cogs Execution Supervisor]

        subgraph "Agents"
            UserInteractionAgent[fa:fa-comments User Interaction]
            DecompositionAgent[fa:fa-sitemap Decomposition]

            subgraph "TEAM 1 Agents"
                direction TB
                Reformulator
                Evaluator
                Validator
            end

            subgraph "TEAM 2 Execution Agents"
                direction TB
                DevelopmentAgent[fa:fa-code Development]
                ResearchAgent[fa:fa-search Research]
                TestingAgent[fa:fa-check-square Testing]
            end
        end
    end

    %% --- SERVICES PARTAGES ---
    subgraph "Shared Services"
        Firestore[(fa:fa-database Firestore)]
        GeminiLLM[(fa:fa-robot Gemini LLM)]
    end

    %% --- FLOW & INTERACTIONS ---

    %% User Flow
    StreamlitUI -- "REST API" --> GRA
    ReactUI -- "REST API" --> GRA

    %% Orchestration Flow
    GRA -- "D√©clenche" --> GlobalSupervisor
    GlobalSupervisor -- "Initie TEAM 1" --> PlanningSupervisor
    GlobalSupervisor -- "Initie TEAM 2" --> ExecutionSupervisor

    %% Supervisor <-> Agent Communication
    GlobalSupervisor <--> |"A2A"| UserInteractionAgent
    PlanningSupervisor <--> |"A2A"| Reformulator
    PlanningSupervisor <--> |"A2A"| Evaluator
    PlanningSupervisor <--> |"A2A"| Validator
    ExecutionSupervisor <--> |"A2A"| DecompositionAgent
    ExecutionSupervisor <--> |"A2A"| DevelopmentAgent
    ExecutionSupervisor <--> |"A2A"| ResearchAgent
    ExecutionSupervisor <--> |"A2A"| TestingAgent

    %% Database Connections
    GRA -- "R/W: Registre Agents" --> Firestore
    GlobalSupervisor -- "R/W: global_plans" --> Firestore
    PlanningSupervisor -- "R/W: task_graphs" --> Firestore
    ExecutionSupervisor -- "R/W: execution_task_graphs" --> Firestore

    %% LLM Connections
    UserInteractionAgent -- "API Call" --> GeminiLLM
    Reformulator -- "API Call" --> GeminiLLM
    Evaluator -- "API Call" --> GeminiLLM
    Validator -- "API Call" --> GeminiLLM
    DecompositionAgent -- "API Call" --> GeminiLLM
    DevelopmentAgent -- "API Call" --> GeminiLLM
    ResearchAgent -- "API Call" --> GeminiLLM
    TestingAgent -- "API Call" --> GeminiLLM
```
https://www.mermaidchart.com/app/projects/f16a002d-be5d-43d1-bdfb-c095ee3316f6/diagrams/49311d22-3e45-4a3a-bc95-dc778de81caf/version/v0.1/edit

* **Langage et Frameworks Backend** :
    * Python 3.11+
    * Agents et GRA : Serveurs ASGI (Uvicorn), SDK A2A (`A2AStarletteApplication`), FastAPI pour le GRA.
* **Logique M√©tier des Agents** : Mod√®les de langage Gemini (g√©r√©e par `src/shared/llm_client.py`), supportant le mode JSON.
* **Base de Donn√©es (Google Cloud Firestore)** :
    * `global_plans`
    * `task_graphs` (pour TEAM 1)
    * `execution_task_graphs` (pour TEAM 2)
    * `agents` (registre GRA)
    * Publication URL du GRA (`service_registry/gra_instance_config`)
* **Communication Inter-Services** :
    * Protocole A2A (via `src/clients/a2a_api_client.py`)
    * API REST (HTTP/JSON) pour Streamlit <-> GRA, Agents <-> GRA.
* **Front-End** : Streamlit, Graphviz.
* **Gestion des T√¢ches Asynchrones** : `asyncio` utilis√© extensivement. `GlobalSupervisorLogic` lance les traitements de TEAM 1 et TEAM 2 en t√¢ches de fond.

## Concepts Cl√©s Mis en ≈íuvre

* **DK/A2A Backbone : Tous les agents et superviseurs communiquent via le protocole A2A de Google Agent Development Kit.
* **Agents ind√©pendants : Chaque agent est un microservice ind√©pendant, d√©ployable en local ou cloud.
* **Architecture Microservices/Agents** : Modularit√© et scalabilit√©.
* **Orchestration √† Plusieurs Niveaux** : `GlobalSupervisorLogic` (clarification, lancement TEAM 1 & 2), `PlanningSupervisorLogic` (TEAM 1), `ExecutionSupervisorLogic` (TEAM 2).
* **Agent Interactif (Human-in-the-Loop)** : `UserInteractionAgent` pour la clarification.
* **Orchestration de T√¢ches (TEAM 1 & TEAM 2)** : Gestion de graphes de t√¢ches (`TaskGraph` pour TEAM 1, `ExecutionTaskGraph` pour TEAM 2).
* **D√©composition de Plan d'Ex√©cution (TEAM 2)** : Le `DecompositionAgent` structure le plan de TEAM 1 en t√¢ches ex√©cutables/exploratoires pour TEAM 2.
* **Agents d'Ex√©cution Sp√©cialis√©s (TEAM 2)** : `DevelopmentAgent`, `ResearchAgent`, `TestingAgent` effectuent des t√¢ches concr√®tes.
* **Ex√©cution de Plan Dynamique (TEAM 2)** : Les t√¢ches exploratoires peuvent g√©n√©rer de nouvelles sous-t√¢ches pendant l'ex√©cution.
* **Service Discovery** : GRA pour la d√©couverte dynamique d'agents.
* **Persistance des Donn√©es Structur√©e** : Collections Firestore distinctes.
* **Traitement It√©ratif et R√©flexif (TEAM 1)** : Boucle de r√©vision.
* **Intelligence Artificielle (LLM)** : Gemini pour la logique des agents.
* **Communication Asynchrone**.

## Architecture G√©n√©rale D√©taill√©e

Le syst√®me est compos√© des principaux √©l√©ments suivants :

* **Agents Sp√©cialis√©s** :
    * `UserInteractionAgent` : Analyse l'objectif, pose des questions, propose un objectif enrichi (JSON).
    * `ReformulatorAgent` (TEAM 1) : Transforme un objectif en plan d√©taill√© structur√©.
    * `EvaluatorAgent` (TEAM 1) : Analyse un plan, identifie forces/faiblesses, score de faisabilit√© (JSON).
    * `ValidatorAgent` (TEAM 1) : Approuve ou rejette un plan √©valu√© avec justification.
    * `DecompositionAgent` (TEAM 2) : D√©compose le plan valid√© de TEAM 1 en un `ExecutionTaskGraph` (JSON) pour TEAM 2.
    * `DevelopmentAgent` (TEAM 2) : G√©n√®re du code source (ex: Python) bas√© sur des sp√©cifications.
    * `ResearchAgent` (TEAM 2) : Effectue des recherches, analyses, et peut proposer de nouvelles sous-t√¢ches.
    * `TestingAgent` (TEAM 2) : Teste des livrables (ex: code) et g√©n√®re des rapports de test (JSON).
    * Chaque agent est un serveur A2A autonome.

* **Gestionnaire de Ressources et d'Agents (GRA)** : Service central (FastAPI/Uvicorn) utilisant Firestore.
    * Registre d'Agents, API Gateway pour le Front-End.

* **Superviseurs (Orchestrateurs)** :
    * `GlobalSupervisorLogic` : Orchestre la phase de clarification interactive, g√®re le `GlobalPlan` sur Firestore, et initie TEAM 1 puis TEAM 2.
    * `PlanningSupervisorLogic` (Orchestrateur de TEAM 1) : G√®re le `TaskGraph` (planification d√©taill√©e) sur Firestore, orchestre les agents de TEAM 1, impl√©mente la boucle de r√©vision.
    * `ExecutionSupervisorLogic` (Orchestrateur de TEAM 2) : G√®re l'`ExecutionTaskGraph` sur Firestore, orchestre les agents de TEAM 2 (Decomposition, Development, Research, Testing) pour ex√©cuter le plan.

* **Client LLM Partag√©** (`src/shared/llm_client.py`) : Interagit avec l'API Gemini.
* **Front-End Streamlit** (`src/app_frontend.py`) : Interface utilisateur.

## Pr√©requis

* Python 3.11+
* Compte Google Cloud avec Firestore activ√©.
* Fichier de cl√© de compte de service JSON (`GOOGLE_APPLICATION_CREDENTIALS`).
* Variables d'environnement : `GOOGLE_APPLICATION_CREDENTIALS`, `GEMINI_API_KEY`.
* (Optionnel) `GRA_PUBLIC_URL`, `AGENT_XXX_PUBLIC_URL`.
* Biblioth√®ques Python list√©es dans `requirements.txt`.
* Graphviz (installation syst√®me).

## Installation

1.  Clonez le d√©p√¥t.
2.  Cr√©ez un environnement virtuel et activez-le.
3.  Installez les d√©pendances :
    ```bash
    pip install -r requirements.txt
    ```
    Le fichier `requirements.txt` devrait contenir au minimum (adaptez si besoin) :
    ```plaintext
    firebase-admin
    google-generativeai
    httpx
    uvicorn[standard]
    fastapi
    a2a-sdk
    streamlit
    graphviz
    pydantic
    ```
4.  Configurez les variables d'environnement.
5.  Installez Graphviz sur votre syst√®me si ce n'est pas d√©j√† fait.

## Utilisation

Pour lancer le syst√®me complet, le GRA et tous les agents doivent √™tre d√©marr√©s.

1.  **D√©marrez le Gestionnaire de Ressources et d'Agents (GRA)** :
    ```bash
    python -m src.services.gra.server
    ```
    V√©rifiez les logs pour la confirmation de la connexion √† Firestore et la publication de son URL.

2.  **D√©marrez les Agents (chacun dans un nouveau terminal)** :
    * Agent d'Interaction Utilisateur (`UserInteractionAgentServer`):
        ```bash
        python -m src.agents.user_interaction_agent.server
        ```
    * Agent Reformulateur (`ReformulatorAgentServer` - TEAM 1):
        ```bash
        python -m src.agents.reformulator.server
        ```
    * Agent √âvaluateur (`EvaluatorAgentServer` - TEAM 1):
        ```bash
        python -m src.agents.evaluator.server
        ```
    * Agent Validateur (`ValidatorAgentServer` - TEAM 1):
        ```bash
        python -m src.agents.validator.server
        ```
    * Agent de D√©composition (`DecompositionAgentServer` - TEAM 2):
        ```bash
        python -m src.agents.decomposition_agent.server
        ```
    * Agent de D√©veloppement (`DevelopmentAgentServer` - TEAM 2):
        ```bash
        python -m src.agents.development_agent.server
        ```
    * Agent de Recherche (`ResearchAgentServer` - TEAM 2):
        ```bash
        python -m src.agents.research_agent.server
        ```
    * Agent de Test (`TestingAgentServer` - TEAM 2):
        ```bash
        python -m src.agents.testing_agent.server
        ```
    V√©rifiez les logs de chaque agent pour confirmer leur enregistrement aupr√®s du GRA.

3.  **Lancez l'Application Streamlit (Front-End)** :
    ```bash
    streamlit run src/app_frontend.py
    ```
    Ouvrez l'URL fournie par Streamlit (g√©n√©ralement `http://localhost:8501`) dans votre navigateur.

    Vous pouvez √©galement tester une interface React tr√®s simple disponible dans le dossier `react_frontend` :
    ```bash
    cd react_frontend && python -m http.server 8080
    ```
    Puis ouvrez [http://localhost:8080/index.html](http://localhost:8080/index.html).
    L'API backend reste disponible sur `http://localhost:8000`. Si besoin, vous pouvez sp√©cifier une autre URL en d√©finissant `BACKEND_API_URL` avant de charger les scripts.

4.  **Utilisez l'Interface** :
    * Soumettez un nouvel objectif.
    * Interagissez avec l'`UserInteractionAgent` pour la clarification.
    * Validez l'objectif pour lancer TEAM 1 (planification).
    * TEAM 1 g√©n√©rera un plan. Si approuv√©, TEAM 2 (ex√©cution) sera initi√©e automatiquement par le `GlobalSupervisorLogic`.
    * Suivez l'√©volution des plans globaux et des graphes de t√¢ches.

5.  **Pour lancer un test complet du flux (Clarification -> TEAM 1 -> TEAM 2) via script backend** :
    (Utile pour tester l'ensemble du pipeline sans l'interface Streamlit.)
    Assurez-vous que le GRA et tous les agents (UserInteraction, TEAM 1, TEAM 2) sont en cours d'ex√©cution, puis :
    ```bash
    python -m src.orchestrators.global_supervisor_logic
    ```
    (Note : Ce script ex√©cute la fonction `main_test_global_supervisor` qui simule le flux complet.)

## Structure du Projet (Principaux Dossiers et Fichiers)
```Markdown
orchestrai-hackathon-ADK/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_interaction_agent/   # Clarification
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ reformulator/             # TEAM¬†1
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ evaluator/                # TEAM¬†1
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validator/                # TEAM¬†1
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decomposition_agent/      # TEAM¬†2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ development_agent/        # TEAM¬†2
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ research_agent/           # TEAM¬†2
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ testing_agent/            # TEAM¬†2
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ... (logic.py, executor.py, server.py pour chaque)
‚îÇ   ‚îú‚îÄ‚îÄ clients/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ a2a_api_client.py
‚îÇ   ‚îú‚îÄ‚îÄ orchestrators/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ global_supervisor_logic.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ planning_supervisor_logic.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ execution_supervisor_logic.py
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ gra/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ server.py
‚îÇ   ‚îî‚îÄ‚îÄ shared/
‚îÇ       ‚îú‚îÄ‚îÄ base_agent_executor.py
‚îÇ       ‚îú‚îÄ‚îÄ base_agent_logic.py
‚îÇ       ‚îú‚îÄ‚îÄ base_executor.py
‚îÇ       ‚îú‚îÄ‚îÄ base_logic.py
‚îÇ       ‚îú‚îÄ‚îÄ firebase_init.py
‚îÇ       ‚îú‚îÄ‚îÄ llm_client.py
‚îÇ       ‚îú‚îÄ‚îÄ service_discovery.py
‚îÇ       ‚îú‚îÄ‚îÄ task_graph_management.py
‚îÇ       ‚îî‚îÄ‚îÄ execution_task_graph_management.py
‚îú‚îÄ‚îÄ src/app_frontend.py               # Interface Streamlit
‚îú‚îÄ‚îÄ src/run_orchestrator.py           # Exemple de lancement TEAM¬†1 seul
‚îú‚îÄ‚îÄ docs/                             # Images et documentation
‚îú‚îÄ‚îÄ react_frontend/                   # Interface React l√©g√®re
‚îú‚îÄ‚îÄ tests/                            # Suite de tests
‚îú‚îÄ‚îÄ scripts/                          # Scripts utilitaires
‚îú‚îÄ‚îÄ deployment.sh                     # D√©ploiement Cloud¬†Run
‚îú‚îÄ‚îÄ build_and_deploy.sh               # Build et d√©ploiement rapides
‚îú‚îÄ‚îÄ test-compose.yml                  # Compose de test local
‚îî‚îÄ‚îÄ requirements.txt
```

## D√©ploiement sur Google Cloud Run et Firebase

Tous les services peuvent √™tre containeris√©s puis d√©ploy√©s sur Cloud Run gr√¢ce
au script `deployment.sh` situ√© √† la racine. Ce script g√©n√®re les Dockerfile,
construit les images, les pousse dans **Artifact Registry** puis cr√©e un service
Cloud Run pour le GRA et pour chacun des agents.

Pr√©‚Äërequis‚ÄØ: installer le SDK gcloud et vous connecter‚ÄØ:

```bash
gcloud auth login
gcloud config set project orchestrai-hackathon
gcloud auth configure-docker
```

Les √©tapes d'automatisation sont ensuite¬†:

```bash
./deployment.sh configure   # g√©n√®re Dockerfile et docker-compose
./deployment.sh build       # construit toutes les images
./deployment.sh push        # envoie les images dans Artifact Registry
./deployment.sh deploy      # cr√©e/maj les services Cloud Run
./deployment.sh deploy_frontend      # d√©ploiement Firebase du front
```

Le script requiert `GEMINI_API_KEY` ainsi qu'un fichier de cl√©s Firebase
donn√© via `GOOGLE_APPLICATION_CREDENTIALS`. Une fois le d√©ploiement termin√©,
l'URL publique du GRA est affich√©e. Elle doit √™tre report√©e dans la variable
`BACKEND_API_URL` du front‚Äëend.

Le front‚Äëend React peut se d√©ploier s√©par√©ment via **Firebase Hosting**¬†:

```bash
npm install -g firebase-tools
firebase login
firebase deploy --only hosting
```

La configuration Firebase se trouve dans `firebase.json` et `.firebaserc`. Par
d√©faut l'interface utilise `http://localhost:8000` comme API. Lorsque le GRA est
h√©berg√© sur Cloud Run, d√©finissez¬†:

```html
<script>
  window.BACKEND_API_URL = 'https://gra-server-xxxx.run.app';
</script>
```

afin d'interroger la bonne URL.

## Pistes d'√âvolution Futures

* Logique de replanification plus sophistiqu√©e dans `ExecutionSupervisorLogic` pour TEAM 2 (actuellement, la d√©composition est initiale, mais des √©checs d'ex√©cution pourraient n√©cessiter une red√©composition partielle ou des t√¢ches alternatives).
* Gestion plus fine des erreurs et m√©canismes de reessai √† tous les niveaux.
* S√©curisation des API.
* Permettre √† `ExecutionSupervisorLogic` de choisir dynamiquement des agents pour des comp√©tences non pr√©-d√©finies dans le plan d√©compos√©, en se basant sur les capacit√©s r√©elles des agents enregistr√©s.
* Introduire un m√©canisme de r√©-√©valuation du plan toutes les X op√©rations.
* Cr√©er et compl√©ter des outils pour les agents.
* Collecter et afficher des statistiques par agent (nombre de t√¢ches ex√©cut√©es, r√©ussies, ...).
